# Simulation data is generated using Latin hypercube sampling for the calibration parameters.
# The observations are generated by adding noise and discrepancy to the simulation output.
# Assume 1D observations and simulation output.
# Simulation output/observations is the FIRST column of the output CSV file.

import numpy as np
from scipy.stats.qmc import LatinHypercube
from true_funcs import TrueParams, eta, zeta

x0_range = (0.02, 3.98)
x1_range = (-0.92, 2.98)
x_dim = 2  # number of control/regression variables

t_ranges = np.array(
    [  # calibration parameter ranges
        [0.25, 0.45],  # theta0
        # [-3.3, -3.0],                   # theta1
        # [0.8, 1.2],                     # theta2
        # [0.6, 1.1],                     # theta3
        # [0.4, 0.6],                     # theta4
    ]
)
n_calib_params = t_ranges.shape[0]  # number of calibration parameters
r = 10 * n_calib_params  # number of simulation runs
n_sim = 25  # number of simulation output points
n_obs = 100  # number of observation points


##### RUN SIMULATOR ######
x0_sim = np.linspace(x0_range[0], x0_range[1], n_sim)
x1_sim = np.linspace(x1_range[0], x1_range[1], n_sim)
TP = TrueParams()
t1, t2, t3, t4 = TP.b, TP.c, TP.d, TP.e

# Generate Latin hypercube samples for the calibration parameters
sampler = LatinHypercube(d=n_calib_params)
sample = sampler.random(n=r)  # sample.shape = (r, d)
for i in range(
    n_calib_params
):  # scale sample onto [theta_ranges[i, 0], theta_ranges[i, 1]]
    sample[:, i] = sample[:, i] * (t_ranges[i, 1] - t_ranges[i, 0]) + t_ranges[i, 0]

x0_sim_grid, x1_sim_grid, t0_sim_grid = np.meshgrid(x0_sim, x1_sim, sample[:, 0])
x0_sim_grid = x0_sim_grid.flatten()
x1_sim_grid = x1_sim_grid.flatten()
t0_sim_grid = t0_sim_grid.flatten()

X_sim = np.array(
    [
        x0_sim_grid,
        x1_sim_grid,
        t0_sim_grid,
        np.repeat(t1, r * n_sim**x_dim),
        np.repeat(t2, r * n_sim**x_dim),
        np.repeat(t3, r * n_sim**x_dim),
        np.repeat(t4, r * n_sim**x_dim),
    ]
).T

eta_output = eta(X_sim[:, :2], X_sim[:, 2:])
np.savetxt(
    "sim-a.csv",
    np.column_stack((eta_output, X_sim[:, [0, 1, 2]])),  # extract x0, x1 and t0
    delimiter=",",
)

##### GENERATE OBSERVATIONS ######
rng = np.random.default_rng(42)  # for reproducibility
x0_field = rng.uniform(x0_range[0], x0_range[1], n_obs)
x1_field = rng.uniform(x1_range[0], x1_range[1], n_obs)

# x0_field_grid, x1_field_grid = np.meshgrid(x0_field, x1_field)
# x0_field_grid = x0_field_grid.flatten()
# x1_field_grid = x1_field_grid.flatten()
x1_field_grid = x1_field.flatten()
x0_field_grid = x0_field.flatten()

X_field = np.array(
    [
        x0_field_grid,
        x1_field_grid,
    ]
).T

obs = zeta(X_field)
obs += np.random.normal(0, np.sqrt(TP.obs_var), n_obs)  # add noise to observations

np.savetxt(
    "obs-a.csv",
    np.column_stack((obs, X_field)),
    delimiter=",",
)
